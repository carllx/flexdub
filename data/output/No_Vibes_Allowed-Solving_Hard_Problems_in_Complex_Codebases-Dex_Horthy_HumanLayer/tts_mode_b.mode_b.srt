1
00:00:00,000 --> 00:00:01,680
[Speaker:Dex] 大家好！

2
00:00:01,680 --> 00:00:04,008
[Speaker:Dex] 大家感觉怎么样？

3
00:00:04,008 --> 00:00:07,800
[Speaker:Dex] 太令人兴奋了。我是 Dex。

4
00:00:07,800 --> 00:00:13,920
[Speaker:Dex] 正如他们在精彩的介绍中所说，我研究智能体已经有一段时间了。

5
00:00:13,920 --> 00:00:22,776
[Speaker:Dex] 我们在六月份 AI Engineer 大会上发表的关于12要素智能体的演讲，是有史以来最受欢迎的演讲之一。

6
00:00:22,776 --> 00:00:27,960
[Speaker:Dex] 我想大概是前八名吧，是那次大会最好的演讲之一。

7
00:00:27,960 --> 00:00:32,280
[Speaker:Dex] 当时我可能提到了关于上下文工程的内容。

8
00:00:32,280 --> 00:00:36,864
[Speaker:Dex] 那我今天为什么站在这里？我要讲些什么？

9
00:00:36,864 --> 00:00:42,168
[Speaker:Dex] 我想谈谈六月份 AI Engineer 大会上我最喜欢的一个演讲。

10
00:00:42,168 --> 00:00:48,288
[Speaker:Dex] 我知道大家昨天都听到了 Igor 的更新，但他们不让我改 PPT 了。

11
00:00:48,288 --> 00:00:53,112
[Speaker:Dex] 所以这里还是要讲 Igor 在六月份谈到的内容。

12
00:00:53,112 --> 00:00:58,056
[Speaker:Dex] 基本上，他们调查了不同规模公司的十万名开发者。

13
00:00:58,056 --> 00:01:05,664
[Speaker:Dex] 发现大多数时候在软件工程中使用 AI，都会导致大量的返工和代码库的混乱。

14
00:01:05,664 --> 00:01:11,304
[Speaker:Dex] 而且它在处理复杂任务或遗留代码库时表现并不好。

15
00:01:11,304 --> 00:01:16,320
[Speaker:Dex] 你可以从图表中看到，虽然你的发布量大大增加了。

16
00:01:16,320 --> 00:01:21,288
[Speaker:Dex] 但很多都只是在重做你上周发布的那些垃圾代码。

17
00:01:21,288 --> 00:01:28,968
[Speaker:Dex] 另一方面是，如果你是在做全新的项目，比如 Vercel 的仪表盘之类的，效果会很好。

18
00:01:28,968 --> 00:01:35,544
[Speaker:Dex] 但如果你要去处理一个有十年历史的 Java 代码库，效果就不那么理想了。

19
00:01:35,544 --> 00:01:38,976
[Speaker:Dex] 这与我的个人经验非常吻合。

20
00:01:38,976 --> 00:01:43,968
[Speaker:Dex] 我和许多聪明的创始人及优秀的工程师交流过。

21
00:01:43,968 --> 00:01:52,320
[Speaker:Dex] 大家都说：垃圾代码太多了，简直是技术债务工厂，它在大型代码库中根本无法工作。

22
00:01:52,320 --> 00:01:57,384
[Speaker:Dex] 甚至有人说：也许等到模型变得更好的那一天吧。

23
00:01:57,384 --> 00:02:01,128
[Speaker:Dex] 但这正是上下文工程的核心所在。

24
00:02:01,128 --> 00:02:07,008
[Speaker:Dex] 上下文工程意味着如何从今天的模型中挖掘最大价值。

25
00:02:07,008 --> 00:02:10,632
[Speaker:Dex] 我们要如何管理我们的上下文窗口？

26
00:02:10,632 --> 00:02:13,992
[Speaker:Dex] 我们在八月份讨论过这个问题。

27
00:02:13,992 --> 00:02:20,880
[Speaker:Dex] 我得承认一件事。第一次使用 Claude Code 时，我并不觉得有什么了不起。

28
00:02:20,880 --> 00:02:26,184
[Speaker:Dex] 我觉得，好吧，是好了一点，我喜欢它的用户体验。

29
00:02:26,184 --> 00:02:30,936
[Speaker:Dex] 但从那以后，我们要作为一个团队解决这个问题。

30
00:02:30,936 --> 00:02:34,944
[Speaker:Dex] 我们实际上能够获得两到三倍的吞吐量。

31
00:02:34,944 --> 00:02:41,448
[Speaker:Dex] 我们的发布量如此之大，以至于我们别无选择，只能改变我们的协作方式。

32
00:02:41,448 --> 00:02:46,656
[Speaker:Dex] 我们彻底重新构建了我们开发软件、沟通和审查的方式。

33
00:02:46,656 --> 00:02:52,680
[Speaker:Dex] 这对于我们这个三人团队来说，花了八周时间，真的非常非常难。

34
00:02:52,680 --> 00:02:57,552
[Speaker:Dex] 但现在我们解决了这个问题，我们再也回不去了。

35
00:02:57,552 --> 00:03:01,200
[Speaker:Dex] 这就是所谓拒绝垃圾代码的核心。

36
00:03:01,200 --> 00:03:05,856
[Speaker:Dex] 我们在九月份在这个话题上有点病毒式传播。

37
00:03:05,856 --> 00:03:12,360
[Speaker:Dex] 我们有成千上万的人访问了 GitHub，获取了我们的研究计划实施提示系统。

38
00:03:12,360 --> 00:03:16,680
[Speaker:Dex] 我们的目标，这也是我们反向推导出来的。

39
00:03:16,680 --> 00:03:24,336
[Speaker:Dex] 我们需要 AI 能够在遗留代码库中良好运作，解决复杂问题，不再产生垃圾代码。

40
00:03:24,336 --> 00:03:30,912
[Speaker:Dex] 并且我们必须保持认知对齐。稍后我会详细解释这意味着什么。

41
00:03:30,912 --> 00:03:35,088
[Speaker:Dex] 当然，我们要尽可能利用好每一个 Token。

42
00:03:35,088 --> 00:03:39,936
[Speaker:Dex] 我们可以向 AI 有意义地卸载的东西真的非常重要。

43
00:03:39,936 --> 00:03:44,472
[Speaker:Dex] 这就是针对编程智能体的高级上下文工程。

44
00:03:44,472 --> 00:03:46,656
[Speaker:Dex] 我想先定个调。

45
00:03:46,656 --> 00:03:55,056
[Speaker:Dex] 使用编程智能体最天真的方式，就是向它索取东西，告诉它为什么错了，重新引导它。

46
00:03:55,056 --> 00:04:01,824
[Speaker:Dex] 一直问啊问，直到你的上下文用完，或者你放弃，或者你崩溃大哭。

47
00:04:01,824 --> 00:04:07,368
[Speaker:Dex] 稍微聪明一点的做法是，大多数人很早就会发现这一点。

48
00:04:07,368 --> 00:04:13,656
[Speaker:Dex] 如果你发现对话跑偏了，最好是重新开始一个新的上下文窗口。

49
00:04:13,656 --> 00:04:18,528
[Speaker:Dex] 你说：好吧，那条路走不通，我们重新开始。

50
00:04:18,528 --> 00:04:24,048
[Speaker:Dex] 同样的提示词，同样的任务，但这次我们要换条路走。

51
00:04:24,048 --> 00:04:27,456
[Speaker:Dex] 你怎么知道什么时候该重开呢？

52
00:04:27,456 --> 00:04:30,168
[Speaker:Dex] 如果你看到这种回复...

53
00:04:30,168 --> 00:04:36,072
[Speaker:Dex] 如果你看到你说得完全正确这句话，大概就是时候重开了。

54
00:04:36,072 --> 00:04:41,568
[Speaker:Dex] 当 Claude 开始说你完全正确的时候，通常意味着它搞砸了。

55
00:04:41,568 --> 00:04:45,792
[Speaker:Dex] 我们可以做得更聪明，我称之为有意压缩。

56
00:04:45,792 --> 00:04:50,112
[Speaker:Dex] 这基本上意味着，无论你是否在正轨上。

57
00:04:50,112 --> 00:04:56,832
[Speaker:Dex] 你都可以利用现有的上下文窗口，让智能体将其压缩成一个 Markdown 文件。

58
00:04:56,832 --> 00:04:59,856
[Speaker:Dex] 你可以审查它，标记它。

59
00:04:59,856 --> 00:05:05,376
[Speaker:Dex] 然后当新的智能体启动时，它可以直接进入工作状态。

60
00:05:05,376 --> 00:05:09,840
[Speaker:Dex] 而不必再做所有的搜索和代码库理解工作。

61
00:05:09,840 --> 00:05:16,728
[Speaker:Dex] 我们在压缩什么？问题在于，是什么占据了上下文窗口的空间？

62
00:05:16,728 --> 00:05:22,656
[Speaker:Dex] 是查找文件、理解代码流、编辑文件、测试和构建输出。

63
00:05:22,656 --> 00:05:30,504
[Speaker:Dex] 如果你用的是那种会把 JSON 和一大堆 UUID 倾倒进上下文窗口的 MCP 工具。

64
00:05:30,504 --> 00:05:33,288
[Speaker:Dex] 那真是上帝保佑你。

65
00:05:33,288 --> 00:05:38,784
[Speaker:Dex] 那么我们应该压缩什么？这是一个很好的压缩示例。

66
00:05:38,784 --> 00:05:44,496
[Speaker:Dex] 这包含了我们正在处理的具体内容、确切的文件和行号。

67
00:05:44,496 --> 00:05:48,048
[Speaker:Dex] 为什么我们要如此痴迷于上下文？

68
00:05:48,048 --> 00:05:51,480
[Speaker:Dex] 因为大语言模型是无状态的。

69
00:05:51,480 --> 00:05:57,864
[Speaker:Dex] 我其实在 YouTube 上因为说它们是纯函数而被喷了，因为它们是不确定的。

70
00:05:57,864 --> 00:06:00,720
[Speaker:Dex] 但它们确实是无状态的。

71
00:06:00,720 --> 00:06:04,968
[Speaker:Dex] 要从 LLM 获得更好表现的唯一方法，

72
00:06:04,968 --> 00:06:07,920
[Speaker:Dex] 就是输入更好的 Token。

73
00:06:07,920 --> 00:06:14,208
[Speaker:Dex] 在循环的每一步，当 Claude 或任何编程智能体选择下一个工具时。

74
00:06:14,208 --> 00:06:19,608
[Speaker:Dex] 可能会有数百个正确的下一步和数百个错误的下一步。

75
00:06:19,608 --> 00:06:24,912
[Speaker:Dex] 唯一影响接下来输出内容的，就是目前的对话内容。

76
00:06:24,912 --> 00:06:28,536
[Speaker:Dex] 所以我们要优化这个上下文窗口。

77
00:06:28,536 --> 00:06:34,488
[Speaker:Dex] 关注四个方面：正确性、完整性、大小，还有一点轨迹。

78
00:06:34,488 --> 00:06:36,792
[Speaker:Dex] 轨迹这点很有趣。

79
00:06:36,792 --> 00:06:41,808
[Speaker:Dex] 很多人说：我告诉智能体做某事，它做错了。

80
00:06:41,808 --> 00:06:48,312
[Speaker:Dex] 所以我纠正了它，吼了它。然后它又做错了，我又吼了它。

81
00:06:48,312 --> 00:06:52,728
[Speaker:Dex] LLM 看着这段对话会想：好的，酷。

82
00:06:52,728 --> 00:06:57,960
[Speaker:Dex] 我做错事，人类吼我；我做错事，人类吼我。

83
00:06:57,960 --> 00:07:02,400
[Speaker:Dex] 所以这段对话中下一个最可能的 Token 是。

84
00:07:02,400 --> 00:07:06,936
[Speaker:Dex] 我最好再做错点什么，好让人类再吼我一次。

85
00:07:06,936 --> 00:07:09,744
[Speaker:Dex] 所以要注意你的轨迹。

86
00:07:09,744 --> 00:07:14,424
[Speaker:Dex] 如果你要反过来看，最糟糕的是错误的信息。

87
00:07:14,424 --> 00:07:18,648
[Speaker:Dex] 然后是缺失的信息，然后是太多噪音。

88
00:07:18,648 --> 00:07:24,672
[Speaker:Dex] 关于上下文大小，Jeff Huntley 做过很多关于编程智能体的研究。

89
00:07:24,672 --> 00:07:26,616
[Speaker:Dex] 他说得很好。

90
00:07:26,616 --> 00:07:31,416
[Speaker:Dex] 你使用上下文窗口越多，你得到的结果就越差。

91
00:07:31,416 --> 00:07:34,992
[Speaker:Dex] 这就引出了一个非常学术的概念。

92
00:07:34,992 --> 00:07:37,056
[Speaker:Dex] 叫做愚笨区。

93
00:07:37,056 --> 00:07:40,896
[Speaker:Dex] 你有大约十六万八千 Token 的窗口。

94
00:07:40,896 --> 00:07:45,960
[Speaker:Dex] 有些是保留给输出和压缩的。这因模型而异。

95
00:07:45,960 --> 00:07:48,768
[Speaker:Dex] 我们用 Claude Code 作为例子。

96
00:07:48,768 --> 00:07:55,536
[Speaker:Dex] 大约在百分之四十的线附近，你会开始看到收益递减，这取决于你的任务。

97
00:07:55,536 --> 00:08:00,456
[Speaker:Dex] 如果你在编程智能体中有太多的 MCP 工具。

98
00:08:00,456 --> 00:08:05,256
[Speaker:Dex] 你就是在愚笨区里工作，你永远不会得到好结果。

99
00:08:05,256 --> 00:08:09,600
[Speaker:Dex] 人们讨论过这个。我不打算详细讲。

100
00:08:09,600 --> 00:08:12,120
[Speaker:Dex] 你的情况可能不同。

101
00:08:12,120 --> 00:08:15,912
[Speaker:Dex] 百分之四十是一个很好的指导线。

102
00:08:15,912 --> 00:08:17,760
[Speaker:Dex] 回到压缩，

103
00:08:17,760 --> 00:08:21,984
[Speaker:Dex] 或者我现在称之为巧妙地避开愚笨区。

104
00:08:21,984 --> 00:08:24,816
[Speaker:Dex] 我们可以使用子智能体。

105
00:08:24,816 --> 00:08:30,768
[Speaker:Dex] 如果你有一个前端子智能体、后端子智能体、QA 子智能体。

106
00:08:30,768 --> 00:08:32,616
[Speaker:Dex] 请停下来。

107
00:08:32,616 --> 00:08:36,744
[Speaker:Dex] 子智能体不是用来搞角色扮演游戏的。

108
00:08:36,744 --> 00:08:39,744
[Speaker:Dex] 它们是用来控制上下文的。

109
00:08:39,744 --> 00:08:47,496
[Speaker:Dex] 所以你可以做的是，比如你想在一个大型代码库中找到某个东西是如何工作的。

110
00:08:47,496 --> 00:08:52,176
[Speaker:Dex] 你可以让编程智能体分叉出一个新的上下文窗口。

111
00:08:52,176 --> 00:08:56,952
[Speaker:Dex] 这个新窗口负责所有的阅读、搜索、查找。

112
00:08:56,952 --> 00:09:00,648
[Speaker:Dex] 阅读整个文件以理解代码库。

113
00:09:00,648 --> 00:09:05,568
[Speaker:Dex] 然后，只返回一条非常简洁的信息给父智能体。

114
00:09:05,568 --> 00:09:09,624
[Speaker:Dex] 就像：嘿，你要的文件在这里。

115
00:09:09,624 --> 00:09:15,024
[Speaker:Dex] 父智能体可以读取那一个文件，然后直接开始工作。

116
00:09:15,024 --> 00:09:17,232
[Speaker:Dex] 这非常强大。

117
00:09:17,232 --> 00:09:24,624
[Speaker:Dex] 如果你正确运用这些，你可以获得很好的响应，然后你可以真正管理好你的上下文。

118
00:09:24,624 --> 00:09:30,120
[Speaker:Dex] 比子智能体更好的是一种我称之为频繁有意压缩的工作流。

119
00:09:33,440 --> 00:09:37,736
[Speaker:Dex] 我们要围绕上下文管理构建整个工作流。

120
00:09:37,736 --> 00:09:41,192
[Speaker:Dex] 我们马上要讨论研究计划实施，

121
00:09:41,192 --> 00:09:46,112
[Speaker:Dex] 但关键是你要不断保持你的上下文窗口较小。

122
00:09:46,112 --> 00:09:50,696
[Speaker:Dex] 这分为三个阶段：研究、计划、实施。

123
00:09:50,696 --> 00:09:54,464
[Speaker:Dex] 我们的目标是全程保持在智能区。

124
00:09:54,464 --> 00:10:00,968
[Speaker:Dex] 研究阶段是为了理解系统如何工作，找到正确的文件，保持客观。

125
00:10:00,968 --> 00:10:05,000
[Speaker:Dex] 这是一个你可以用来做研究的提示词。

126
00:10:05,000 --> 00:10:10,160
[Speaker:Dex] 这是研究提示词的输出示例。这些都是开源的。

127
00:10:10,160 --> 00:10:13,160
[Speaker:Dex] 你可以自己去获取并尝试。

128
00:10:13,160 --> 00:10:19,088
[Speaker:Dex] 计划阶段，你要列出确切的步骤，包含文件名和代码片段。

129
00:10:19,088 --> 00:10:22,952
[Speaker:Dex] 你要非常明确每次变更后如何测试。

130
00:10:22,952 --> 00:10:28,112
[Speaker:Dex] 这是一个好的计划提示词。这是我们的一个计划。

131
00:10:28,112 --> 00:10:33,176
[Speaker:Dex] 里面有实际的代码片段。然后我们就去实施。

132
00:10:33,176 --> 00:10:40,016
[Speaker:Dex] 如果你读过这些计划，你会发现即使是世界上最笨的模型也不太可能搞砸。

133
00:10:40,016 --> 00:10:44,360
[Speaker:Dex] 我们就按计划执行，保持低上下文占用。

134
00:10:44,360 --> 00:10:50,432
[Speaker:Dex] 正如我所说，计划阶段是整个过程中最不令人兴奋的部分。

135
00:10:50,432 --> 00:10:52,856
[Speaker:Dex] 我想把这付诸实践。

136
00:10:52,856 --> 00:10:57,896
[Speaker:Dex] 我和我的朋友 Vaibhav 做播客，他是 BoundaryML 的 CEO。

137
00:10:57,896 --> 00:11:02,744
[Speaker:Dex] 我说：嘿，我要尝试一次性解决你们那个三

138
00:11:02,744 --> 00:11:06,296
[Speaker:Dex] 十万行 Rust 代码库中的一个问题。

139
00:11:06,296 --> 00:11:09,440
[Speaker:Dex] 整个节目大约一个半小时。

140
00:11:09,440 --> 00:11:15,680
[Speaker:Dex] 我现在不详细讲，但我们做了很多研究，然后因为不好就扔掉了。

141
00:11:15,680 --> 00:11:22,544
[Speaker:Dex] 然后我们制定了计划，比较了有研究和没有研究的结果。很有趣。

142
00:11:22,544 --> 00:11:24,824
[Speaker:Dex] 那是周一晚上。

143
00:11:24,824 --> 00:11:28,568
[Speaker:Dex] 到周二早上，CTO 看到了 PR，

144
00:11:28,568 --> 00:11:34,736
[Speaker:Dex] 没意识到我是为播客做的，就说：看起来不错，下个版本发布。

145
00:11:34,736 --> 00:11:39,008
[Speaker:Dex] 我觉得他有点困惑。这是那个计划。

146
00:11:39,008 --> 00:11:43,640
[Speaker:Dex] 总之，确认了：它在遗留代码库中有效，

147
00:11:43,640 --> 00:11:45,968
[Speaker:Dex] 且没有垃圾代码。

148
00:11:45,968 --> 00:11:51,656
[Speaker:Dex] 但我想看看能否解决复杂问题。Vaibhav 还是有些怀疑。

149
00:11:51,656 --> 00:11:57,512
[Speaker:Dex] 我们在周六坐了七个小时，向 BAML 发布了三万五千行代码。

150
00:11:57,512 --> 00:12:04,184
[Speaker:Dex] 其中一个 PR 大约一周后就被合并了。我得说有些是代码生成。

151
00:12:04,184 --> 00:12:11,792
[Speaker:Dex] 你更新行为，所有的黄金文件都会更新。但那天我们确实发布了很多代码。

152
00:12:11,792 --> 00:12:16,784
[Speaker:Dex] 他估计这通常需要一到两周，我们七小时完成了。

153
00:12:16,784 --> 00:12:22,832
[Speaker:Dex] 太酷了。我们可以解决复杂问题。但这也有局限性。

154
00:12:22,832 --> 00:12:27,920
[Speaker:Dex] 我和我的朋友 Blake 试着从 Parquet Java 中移除 Hadoop 依赖。

155
00:12:27,920 --> 00:12:30,992
[Speaker:Dex] 如果你知道 Parquet Java 是什么，

156
00:12:30,992 --> 00:12:33,896
[Speaker:Dex] 我对你的遭遇表示同情。

157
00:12:33,896 --> 00:12:38,720
[Speaker:Dex] 那次非常不顺利。这是计划，这是研究。

158
00:12:38,720 --> 00:12:44,552
[Speaker:Dex] 在某一点上，我们不得不把所有东西都扔掉，回到白板上。

159
00:12:44,552 --> 00:12:48,224
[Speaker:Dex] 一旦我们了解了所有的坑在哪里，

160
00:12:48,224 --> 00:12:52,808
[Speaker:Dex] 我们就回到：这实际上要怎么组合在一起？

161
00:12:52,808 --> 00:12:57,056
[Speaker:Dex] 这就引出了 Jake 稍后要谈的一个有趣观点。

162
00:12:57,056 --> 00:13:01,208
[Speaker:Dex] 不要外包思考。AI 不能替代思考。

163
00:13:01,208 --> 00:13:06,800
[Speaker:Dex] 它只能放大你已经完成的思考，或者放大你的缺乏思考。

164
00:13:06,800 --> 00:13:10,880
[Speaker:Dex] 人们问：Dex，这就是规格驱动开发吗？

165
00:13:10,880 --> 00:13:15,296
[Speaker:Dex] 不。规格驱动开发这个词已经坏掉了。

166
00:13:15,296 --> 00:13:21,248
[Speaker:Dex] 不是理念坏了，是这个词坏了。它没有被很好地定义。

167
00:13:21,248 --> 00:13:26,672
[Speaker:Dex] 很多人说规格，他们的意思只是一个更详细的提示词。

168
00:13:26,672 --> 00:13:34,184
[Speaker:Dex] 有人记得这张图吗？有人知道这是什么吗？好吧，这是个冷门梗。

169
00:13:34,184 --> 00:13:41,888
[Speaker:Dex] 由于语义扩散，永远不会有智能体之年。Martin Fowler 在 2006 年说过这个。

170
00:13:41,888 --> 00:13:45,584
[Speaker:Dex] 我们想出一个好词，有个好定义，

171
00:13:45,584 --> 00:13:52,640
[Speaker:Dex] 然后每个人都兴奋起来，开始用它指代一百种不同的东西，然后它就没用了。

172
00:13:52,640 --> 00:13:57,992
[Speaker:Dex] 智能体是人、是微服务、是聊天机器人、是工作流。

173
00:13:57,992 --> 00:14:04,352
[Speaker:Dex] 感谢 Simon，我们回到了起点。智能体只是循环中的工具。

174
00:14:04,352 --> 00:14:10,904
[Speaker:Dex] 规格驱动开发也是一样。我以前在演讲开头放过 Sean 的幻灯片。

175
00:14:10,904 --> 00:14:17,240
[Speaker:Dex] 但这导致很多人关注错误的东西。他说的是：忘掉代码。

176
00:14:17,240 --> 00:14:21,608
[Speaker:Dex] 代码现在就像汇编，你只需要关注 Markdown。

177
00:14:21,608 --> 00:14:28,328
[Speaker:Dex] 很酷的想法，但人们现在认为写个更好的提示词就是规格驱动开发。

178
00:14:28,328 --> 00:14:34,160
[Speaker:Dex] 或者是产品需求文档，或者是可验证的反馈循环和背压。

179
00:14:34,160 --> 00:14:38,768
[Speaker:Dex] 也许是像 Sean 教我们的那样把代码当作汇编。

180
00:14:38,768 --> 00:14:43,208
[Speaker:Dex] 但很多人只是在编码时用一堆 Markdown 文件。

181
00:14:43,208 --> 00:14:45,776
[Speaker:Dex] 或者我最喜欢的，

182
00:14:45,776 --> 00:14:50,144
[Speaker:Dex] 我上周才发现的：规格是开源库的文档。

183
00:14:50,144 --> 00:14:55,112
[Speaker:Dex] 所以它完了。规格驱动开发被过度炒作了，

184
00:14:55,112 --> 00:14:58,688
[Speaker:Dex] 现在没用了，语义已经扩散了。

185
00:14:58,688 --> 00:15:03,440
[Speaker:Dex] 所以我想谈谈四个实际有效的战术步骤，

186
00:15:03,440 --> 00:15:07,424
[Speaker:Dex] 这是我们在内部和用户中发现有效的。

187
00:15:07,424 --> 00:15:13,688
[Speaker:Dex] 我们做研究，弄清楚系统如何工作。还记得《记忆碎片》吗？

188
00:15:13,688 --> 00:15:18,728
[Speaker:Dex] 正如 Peter 所说，这是关于上下文工程最好的电影。

189
00:15:18,728 --> 00:15:21,560
[Speaker:Dex] 男主角醒来没有记忆，

190
00:15:21,560 --> 00:15:26,552
[Speaker:Dex] 必须读自己的纹身才知道自己是谁、在做什么。

191
00:15:26,552 --> 00:15:31,712
[Speaker:Dex] 如果你不给智能体做入职培训，它们就会开始编造东西。

192
00:15:31,712 --> 00:15:39,608
[Speaker:Dex] 如果这是你的团队，这对大多数人来说是简化的。你们大多数人有更大的组织。

193
00:15:39,608 --> 00:15:46,352
[Speaker:Dex] 假设你想在这里做一些工作。你可以在每个仓库里放入职培训内容。

194
00:15:46,352 --> 00:15:51,704
[Speaker:Dex] 你放一堆上下文。这是仓库，这是它的工作原理。

195
00:15:51,704 --> 00:15:55,640
[Speaker:Dex] 这是代码库中所有上下文的压缩，

196
00:15:55,640 --> 00:15:59,624
[Speaker:Dex] 智能体可以在开始工作前提前看到。

197
00:15:59,624 --> 00:16:04,136
[Speaker:Dex] 这很有挑战性，因为有时候它会变得太长。

198
00:16:04,136 --> 00:16:09,992
[Speaker:Dex] 当你的代码库变得很大时，你要么让它更长，要么遗漏信息。

199
00:16:09,992 --> 00:16:15,080
[Speaker:Dex] 当你读这个五百万行的大型单体仓库的上下文时，

200
00:16:15,080 --> 00:16:20,144
[Speaker:Dex] 你会用掉所有的智能区只是为了学习它如何工作。

201
00:16:20,144 --> 00:16:25,184
[Speaker:Dex] 然后你在愚笨区里就无法做任何好的工具调用了。

202
00:16:25,184 --> 00:16:27,896
[Speaker:Dex] 所以你可以分层切分。

203
00:16:27,896 --> 00:16:32,312
[Speaker:Dex] 你可以做渐进式披露。你可以把它拆开。

204
00:16:32,312 --> 00:16:36,296
[Speaker:Dex] 你可以在每个仓库的根目录放一个文件，

205
00:16:36,296 --> 00:16:41,720
[Speaker:Dex] 然后在每一层根据你在哪里工作添加额外的上下文。

206
00:16:41,720 --> 00:16:46,280
[Speaker:Dex] 我们不记录文件本身，因为它们是真相的来源。

207
00:16:46,280 --> 00:16:52,784
[Speaker:Dex] 但当你的智能体工作时，你拉入根上下文，然后拉入子上下文。

208
00:16:52,784 --> 00:16:58,400
[Speaker:Dex] 我们不讨论具体工具，你可以用 Claude，可以用钩子，随便什么。

209
00:16:58,400 --> 00:17:04,736
[Speaker:Dex] 但你在智能区仍然有足够的空间，因为你只拉入你需要知道的内容。

210
00:17:04,736 --> 00:17:09,344
[Speaker:Dex] 问题是它会过时。每次你发布新功能。

211
00:17:09,344 --> 00:17:15,416
[Speaker:Dex] 你需要缓存、验证和重建这个内部文档的大部分内容。

212
00:17:15,416 --> 00:17:20,384
[Speaker:Dex] 你可以用很多 AI，把更新这个作为你流程的一部分。

213
00:17:20,384 --> 00:17:26,768
[Speaker:Dex] 但我想问一个问题：在实际代码、函数名、注释和文档之间。

214
00:17:30,328 --> 00:17:34,504
[Speaker:Dex] 有人想猜猜这个图表的 Y 轴是什么吗？

215
00:17:34,504 --> 00:17:40,024
[Speaker:Dex] 实际上是你在代码库任何部分能找到的谎言数量。

216
00:17:40,024 --> 00:17:46,792
[Speaker:Dex] 你可以把更新这个作为流程的一部分，但你可能不应该，因为你可能不会做。

217
00:17:46,792 --> 00:17:50,440
[Speaker:Dex] 我们更喜欢的是按需压缩上下文。

218
00:17:50,440 --> 00:17:58,240
[Speaker:Dex] 如果我要构建一个与 SCM 提供商、Jira 和 Linear 相关的功能，我只需要给它一点引导。

219
00:17:58,240 --> 00:18:02,968
[Speaker:Dex] 我会说：嘿，我们要看这边代码库的这部分。

220
00:18:02,968 --> 00:18:09,256
[Speaker:Dex] 一个好的研究提示词或斜杠命令可能会启动一系列子智能体，

221
00:18:09,256 --> 00:18:12,400
[Speaker:Dex] 穿越代码库的垂直切片。

222
00:18:12,400 --> 00:18:15,304
[Speaker:Dex] 然后构建一个研究文档，

223
00:18:15,304 --> 00:18:19,504
[Speaker:Dex] 这是基于代码本身关键部分的真实快照。

224
00:18:19,504 --> 00:18:23,584
[Speaker:Dex] 我们在压缩真相。规划是杠杆。

225
00:18:23,584 --> 00:18:30,040
[Speaker:Dex] 规划是关于对意图的压缩。在计划中我们会列出确切的步骤。

226
00:18:30,040 --> 00:18:35,104
[Speaker:Dex] 我们拿着研究、PRD 或 bug 单或其他任何东西，

227
00:18:35,104 --> 00:18:39,976
[Speaker:Dex] 创建一个计划文件。所以我们再次压缩。

228
00:18:39,976 --> 00:18:43,216
[Speaker:Dex] 我想停下来谈谈认知对齐。

229
00:18:43,216 --> 00:18:47,008
[Speaker:Dex] 有人知道代码审查是为了什么吗？

230
00:18:47,008 --> 00:18:52,048
[Speaker:Dex] 认知对齐。是的，它是关于确保事情正确，

231
00:18:52,048 --> 00:18:57,040
[Speaker:Dex] 但最重要的是让团队对代码库的变化保持一致。

232
00:18:57,040 --> 00:19:02,968
[Speaker:Dex] 我每周可以读几百行计划书。但我不想读几千行 Go 代码。

233
00:19:02,968 --> 00:19:09,616
[Speaker:Dex] 抱歉，我读不了一千行。很难。我能做到，但我不想。

234
00:19:09,616 --> 00:19:14,296
[Speaker:Dex] 随着我们团队的成长，所有代码都会被审查。

235
00:19:14,296 --> 00:19:18,736
[Speaker:Dex] 我们不是不读代码，但作为团队的技术领导。

236
00:19:18,736 --> 00:19:23,824
[Speaker:Dex] 我可以读计划，保持了解最新情况，这就足够了。

237
00:19:23,824 --> 00:19:29,368
[Speaker:Dex] 我可以及早发现一些问题，并保持对系统如何演变的理解。

238
00:19:29,368 --> 00:19:32,464
[Speaker:Dex] Mitchell 有一篇很好的文章，

239
00:19:32,464 --> 00:19:35,944
[Speaker:Dex] 讲他如何把 AMP 线程放在 PR 上。

240
00:19:35,944 --> 00:19:43,912
[Speaker:Dex] 这样你不仅能看到 GitHub 上的一堵绿色代码墙，还能看到确切的步骤、提示词。

241
00:19:43,912 --> 00:19:50,848
[Speaker:Dex] 嘿，我最后运行了构建，它通过了。这让审查者经历了一次旅程。

242
00:19:50,848 --> 00:19:56,704
[Speaker:Dex] 这是 GitHub PR 做不到的。当你发布两到三倍的代码时。

243
00:19:56,704 --> 00:20:03,856
[Speaker:Dex] 你真的需要找到方法让团队保持一致，展示你做的步骤和手动测试的方法。

244
00:20:03,856 --> 00:20:10,000
[Speaker:Dex] 你的目标是杠杆。你需要高度确信模型会做正确的事情。

245
00:20:10,000 --> 00:20:15,328
[Speaker:Dex] 我无法读这个计划就知道实际会发生什么代码变更。

246
00:20:15,328 --> 00:20:18,016
[Speaker:Dex] 所以随着时间推移，

247
00:20:18,016 --> 00:20:22,384
[Speaker:Dex] 我们的计划迭代到包含实际的代码片段。

248
00:20:22,384 --> 00:20:28,792
[Speaker:Dex] 所以你的目标是杠杆。你想要压缩意图，你想要可靠的执行。

249
00:20:28,792 --> 00:20:34,408
[Speaker:Dex] 我有物理背景。我们喜欢在峰值和曲线的中心画线。

250
00:20:34,408 --> 00:20:39,208
[Speaker:Dex] 随着计划变长，可靠性上升，可读性下降。

251
00:20:39,208 --> 00:20:43,768
[Speaker:Dex] 对你、你的团队和代码库来说有一个甜蜜点。

252
00:20:43,768 --> 00:20:46,336
[Speaker:Dex] 你应该尝试找到它。

253
00:20:46,336 --> 00:20:52,504
[Speaker:Dex] 因为当我们审查研究和计划时，如果它们好，我们就能获得认知对齐。

254
00:20:52,504 --> 00:20:59,752
[Speaker:Dex] 不要外包思考。我以前说过，这不是魔法。没有完美的提示词。

255
00:20:59,752 --> 00:21:03,592
[Speaker:Dex] 如果你不读计划，它仍然不会工作。

256
00:21:03,592 --> 00:21:07,336
[Speaker:Dex] 所以我们围绕你构建了整个流程，

257
00:21:07,336 --> 00:21:11,224
[Speaker:Dex] 你在制定计划时与智能体来回交流。

258
00:21:11,224 --> 00:21:19,216
[Speaker:Dex] 如果你需要同行评审，你可以发给别人说：这个计划看起来对吗？这是正确的方法吗？

259
00:21:19,216 --> 00:21:22,768
[Speaker:Dex] Jake 写了一篇很好的博客文章，

260
00:21:22,768 --> 00:21:29,080
[Speaker:Dex] 让研究计划实施有价值的是你这个人在循环中确保它正确。

261
00:21:29,080 --> 00:21:32,800
[Speaker:Dex] 如果你从这个演讲中带走一件事，

262
00:21:32,800 --> 00:21:38,032
[Speaker:Dex] 那就是：一行糟糕的代码就是一行糟糕的代码。

263
00:21:38,032 --> 00:21:42,640
[Speaker:Dex] 一个糟糕的计划可能是一百行糟糕的代码。

264
00:21:42,640 --> 00:21:45,064
[Speaker:Dex] 一行糟糕的研究，

265
00:21:45,064 --> 00:21:50,008
[Speaker:Dex] 比如对系统如何工作的误解，你整个东西都会完蛋。

266
00:21:50,008 --> 00:21:56,872
[Speaker:Dex] 你会把模型送往错误的方向。所以当我们在内部和与用户合作时。

267
00:21:56,872 --> 00:22:03,904
[Speaker:Dex] 我们不断尝试把人类的精力和注意力转移到这个管道中杠杆率最高的部分。

268
00:22:03,904 --> 00:22:11,728
[Speaker:Dex] 不要外包思考。小心那些只是为了让你感觉良好而输出一堆 Markdown 文件的工具。

269
00:22:11,728 --> 00:22:16,936
[Speaker:Dex] 我不会在这里点名。有时候这是杀鸡用牛刀。

270
00:22:16,936 --> 00:22:21,928
[Speaker:Dex] 我喜欢这样想：你不总是需要完整的研究计划实施。

271
00:22:21,928 --> 00:22:28,336
[Speaker:Dex] 有时你需要更多，有时你需要更少。如果你只是改个按钮颜色。

272
00:22:28,336 --> 00:22:32,176
[Speaker:Dex] 直接告诉智能体该怎么做就行了。

273
00:22:32,176 --> 00:22:35,656
[Speaker:Dex] 如果你做简单的计划和小功能，

274
00:22:35,656 --> 00:22:39,256
[Speaker:Dex] 如果你跨多个仓库做中等功能。

275
00:22:39,256 --> 00:22:46,432
[Speaker:Dex] 那就做一次研究，然后制定计划。基本上，你能解决的最难的问题。

276
00:22:46,432 --> 00:22:51,832
[Speaker:Dex] 天花板会随着你愿意做的上下文工程压缩工作而提高。

277
00:22:51,832 --> 00:22:55,816
[Speaker:Dex] 如果你在右上角，你可能需要做更多。

278
00:22:55,816 --> 00:23:02,440
[Speaker:Dex] 很多人问我：我怎么知道要用多少上下文工程？这需要练习。

279
00:23:02,440 --> 00:23:07,024
[Speaker:Dex] 你会弄错。你必须一遍又一遍地弄错。

280
00:23:07,024 --> 00:23:13,144
[Speaker:Dex] 有时你做得太大，有时太小。选一个工具，多加练习。

281
00:23:13,144 --> 00:23:19,000
[Speaker:Dex] 我建议不要在 Claude、Codex 和所有这些不同工具之间来回切换。

282
00:23:19,000 --> 00:23:25,000
[Speaker:Dex] 我不是一个喜欢缩写的人。我们说过规格驱动开发坏掉了。

283
00:23:25,000 --> 00:23:29,392
[Speaker:Dex] 研究计划实施我不认为会是最终的步骤。

284
00:23:29,392 --> 00:23:34,504
[Speaker:Dex] 重要的是压缩、上下文工程和保持在智能区。

285
00:23:34,504 --> 00:23:39,880
[Speaker:Dex] 但人们叫它 RPI，我也没办法。所以要小心。

286
00:23:39,880 --> 00:23:43,888
[Speaker:Dex] 没有完美的提示词。没有银弹。

287
00:23:43,888 --> 00:23:47,128
[Speaker:Dex] 如果你真的想要一个炒作的词，

288
00:23:47,128 --> 00:23:52,096
[Speaker:Dex] 你可以叫它线束工程，这是上下文工程的一部分。

289
00:23:52,096 --> 00:23:57,952
[Speaker:Dex] 这是你如何与 Codex、Claude、Cursor 等工具的集成点进行整合。

290
00:23:57,952 --> 00:24:00,880
[Speaker:Dex] 如何自定义你的代码库。

291
00:24:00,880 --> 00:24:07,840
[Speaker:Dex] 那么接下来是什么？我认为编程智能体的东西实际上会被商品化。

292
00:24:07,840 --> 00:24:11,896
[Speaker:Dex] 人们会学会如何做这个并变得更好。

293
00:24:11,896 --> 00:24:17,320
[Speaker:Dex] 困难的部分是如何调整你的团队、工作流和 SDLC。

294
00:24:17,320 --> 00:24:21,952
[Speaker:Dex] 以适应百分之九十九的代码由 AI 生成的世界。

295
00:24:21,952 --> 00:24:25,408
[Speaker:Dex] 如果你搞不定这个，你就完了。

296
00:24:25,408 --> 00:24:31,912
[Speaker:Dex] 因为有一个鸿沟在增长：高级工程师不采用 AI，因为它没让他们快多少。

297
00:24:31,912 --> 00:24:39,088
[Speaker:Dex] 初级和中级工程师用得很多，因为它填补了技能差距，但也产生了一些垃圾代码。

298
00:24:39,088 --> 00:24:46,648
[Speaker:Dex] 然后高级工程师每周都越来越讨厌它，因为他们在清理上周 Cursor 产生的垃圾。

299
00:24:46,648 --> 00:24:51,592
[Speaker:Dex] 这不是 AI 的错。这不是中级工程师的错。

300
00:24:51,592 --> 00:24:56,776
[Speaker:Dex] 文化变革真的很难，如果要成功，需要自上而下。

301
00:24:56,776 --> 00:25:02,584
[Speaker:Dex] 所以如果你是公司的技术领导者，选一个工具，多加练习。

302
00:25:02,584 --> 00:25:08,896
[Speaker:Dex] 如果你想帮忙，我们正在招聘。我们正在构建一个智能体 IDE。

303
00:25:08,896 --> 00:25:13,000
[Speaker:Dex] 帮助各种规模的团队加速迈向百分

304
00:25:13,000 --> 00:25:16,840
[Speaker:Dex] 之九十九 AI 生成代码的旅程。

305
00:25:16,840 --> 00:25:26,824
[Speaker:Dex] 如果你想和我们合作，我们很乐意聊聊。访问我们的网站，发邮件，或者来走廊找我。谢谢大家！

